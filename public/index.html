<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description" content="Learn to identify all 88 constellations - mobile-friendly quiz app">
    <meta name="theme-color" content="#0f172a">
    <title>Constellation Quiz</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            min-height: 100vh;
            padding: 1rem;
            line-height: 1.6;
        }

        #root {
            max-width: 800px;
            margin: 0 auto;
        }

        #root:has(.sky-view-screen) {
            max-width: 1500px;
        }

        .sky-view-screen .card {
            max-width: 1450px;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 0.5rem;
            color: #f1f5f9;
            text-align: center;
        }

        h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #cbd5e1;
        }

        .subtitle {
            text-align: center;
            color: #94a3b8;
            margin-bottom: 2rem;
            font-size: 0.95rem;
        }

        .card {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid rgba(148, 163, 184, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        .setup-grid {
            display: grid;
            gap: 1.5rem;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        label {
            font-weight: 500;
            color: #cbd5e1;
            font-size: 0.95rem;
        }

        select, input[type="text"] {
            padding: 0.75rem;
            background: #1e293b;
            border: 1px solid #475569;
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 1rem;
            transition: all 0.2s;
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        button {
            padding: 0.875rem 1.5rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px;
            touch-action: manipulation;
        }

        button:hover {
            background: #2563eb;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #475569;
            cursor: not-allowed;
            transform: none;
        }

        .button-primary {
            background: #3b82f6;
            width: 100%;
            margin-top: 1rem;
        }

        .button-secondary {
            background: #64748b;
        }

        .button-secondary:hover {
            background: #475569;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            gap: 1rem;
        }

        .score {
            font-size: 1.25rem;
            font-weight: 600;
            color: #60a5fa;
        }

        .question-number {
            font-size: 1rem;
            color: #94a3b8;
        }

        canvas {
            display: block;
            width: 100%;
            max-width: 500px;
            height: auto;
            margin: 0 auto 1.5rem;
            background: #0f172a;
            border-radius: 8px;
            border: 1px solid #334155;
        }

        .answer-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .answer-button {
            padding: 1rem;
            background: #1e293b;
            border: 2px solid #475569;
            color: #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 50px;
        }

        .answer-button:hover {
            background: #334155;
            border-color: #64748b;
        }

        .answer-button.correct {
            background: #065f46;
            border-color: #10b981;
            color: #d1fae5;
        }

        .answer-button.incorrect {
            background: #7f1d1d;
            border-color: #ef4444;
            color: #fecaca;
        }

        .feedback {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 8px;
            font-weight: 500;
            text-align: center;
        }

        .feedback.correct {
            background: rgba(6, 95, 70, 0.3);
            border: 1px solid #10b981;
            color: #d1fae5;
        }

        .feedback.incorrect {
            background: rgba(127, 29, 29, 0.3);
            border: 1px solid #ef4444;
            color: #fecaca;
        }

        .text-input-container {
            margin-top: 1.5rem;
        }

        .text-input-container input {
            width: 100%;
            margin-bottom: 1rem;
        }

        .results-summary {
            text-align: center;
            margin-bottom: 2rem;
        }

        .results-summary .score-big {
            font-size: 3rem;
            font-weight: 700;
            color: #60a5fa;
            margin: 1rem 0;
        }

        .results-summary .percentage {
            font-size: 1.5rem;
            color: #94a3b8;
        }

        .missed-list {
            list-style: none;
            display: grid;
            gap: 0.5rem;
        }

        .missed-list li {
            padding: 0.75rem;
            background: rgba(127, 29, 29, 0.2);
            border-left: 3px solid #ef4444;
            border-radius: 4px;
            color: #fecaca;
        }

        .button-group {
            display: grid;
            gap: 1rem;
            margin-top: 2rem;
        }

        @media (min-width: 640px) {
            .button-group {
                grid-template-columns: repeat(2, 1fr);
            }

            h1 {
                font-size: 2.5rem;
            }
        }

        .loading {
            text-align: center;
            padding: 3rem;
            color: #94a3b8;
        }

        .ascii-container {
            background: #0f172a;
            border-radius: 8px;
            border: 1px solid #334155;
            padding: 1rem;
            margin: 0 auto 1.5rem;
            max-width: 100%;
            overflow-x: auto;
        }

        .ascii-art {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.55rem;
            line-height: 1.1;
            color: #e2e8f0;
            white-space: pre;
            text-align: left;
        }

        .back-button {
            background: #64748b;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }

        .back-button:hover {
            background: #475569;
        }

        @media (min-width: 768px) {
            .ascii-art {
                font-size: 0.7rem;
            }

            .quiz-desktop-grid {
                display: grid;
                grid-template-columns: 500px 1fr;
                gap: 2rem;
                align-items: start;
            }

            .quiz-constellation-col {
                position: sticky;
                top: 1rem;
            }

            .quiz-interaction-col {
                min-height: 500px;
                display: flex;
                flex-direction: column;
                justify-content: space-between;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>


    <!-- React from CDN -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Quiz App -->
    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // Main App Component
        function App() {
            const [screen, setScreen] = useState('setup'); // 'setup', 'quiz', 'results'
            const [config, setConfig] = useState(null);
            const [savedConfig, setSavedConfig] = useState(null); // Persist settings when returning to menu
            const [quizState, setQuizState] = useState(null);
            const [constellationData, setConstellationData] = useState(null);
            const [starCatalogData, setStarCatalogData] = useState(null);
            const [loadingError, setLoadingError] = useState(null);

            // Load constellation data from external JSON
            useEffect(() => {
                fetch('../data/constellation_data.json')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load constellation data: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        setConstellationData(data);
                    })
                    .catch(error => {
                        console.error('Error loading constellation data:', error);
                        setLoadingError(error.message);
                    });
            }, []);

            // Load star catalog when config changes
            useEffect(() => {
                if (!config || !config.showBackgroundStars) {
                    setStarCatalogData(null);
                    return;
                }

                const filename = '../data/background_stars_visible.json';

                fetch(filename)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load star catalog: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        setStarCatalogData(data);
                    })
                    .catch(error => {
                        console.error('Error loading star catalog:', error);
                        // Don't block quiz if star catalog fails to load
                        setStarCatalogData(null);
                    });
            }, [config]);

            const startQuiz = (quizConfig) => {
                setConfig(quizConfig);
                setSavedConfig(quizConfig); // Save config for when user returns to menu
                const questions = generateQuestions(quizConfig, constellationData, starCatalogData);
                setQuizState({
                    questions,
                    currentIndex: 0,
                    score: 0,
                    answers: []
                });
                setScreen('quiz');
            };

            const handleAnswer = (isCorrect, userAnswer, correctAnswer) => {
                const newAnswers = [...quizState.answers, {
                    constellation: correctAnswer,
                    userAnswer,
                    correct: isCorrect
                }];

                const newScore = isCorrect ? quizState.score + 1 : quizState.score;

                setQuizState({
                    ...quizState,
                    score: newScore,
                    answers: newAnswers
                });
            };

            const nextQuestion = () => {
                if (quizState.currentIndex + 1 < quizState.questions.length) {
                    setQuizState({
                        ...quizState,
                        currentIndex: quizState.currentIndex + 1
                    });
                } else {
                    setScreen('results');
                }
            };

            const restartQuiz = () => {
                startQuiz(config);
            };

            const newQuiz = () => {
                setScreen('setup');
                setConfig(null);
                setQuizState(null);
            };

            const backToSetup = () => {
                setScreen('setup');
            };

            // Show loading state
            if (!constellationData && !loadingError) {
                return (
                    <div style={{textAlign: 'center', padding: '3rem'}}>
                        <h1>üåü Constellation Quiz</h1>
                        <p style={{marginTop: '2rem', fontSize: '1.25rem'}}>Loading constellation data...</p>
                    </div>
                );
            }

            // Show error state
            if (loadingError) {
                return (
                    <div style={{textAlign: 'center', padding: '3rem'}}>
                        <h1>‚ùå Error</h1>
                        <div className="card" style={{marginTop: '2rem'}}>
                            <p style={{color: '#dc2626', marginBottom: '1rem'}}>Failed to load constellation data:</p>
                            <p style={{fontFamily: 'monospace', background: '#1e293b', padding: '1rem', borderRadius: '0.5rem'}}>
                                {loadingError}
                            </p>
                            <p style={{marginTop: '1.5rem', fontSize: '0.875rem', color: '#94a3b8'}}>
                                Make sure you're running a local HTTP server:
                            </p>
                            <p style={{fontFamily: 'monospace', marginTop: '0.5rem', fontSize: '0.875rem'}}>
                                python -m http.server 8000
                            </p>
                        </div>
                    </div>
                );
            }

            const startSkyView = () => {
                setScreen('skyview');
            };

            return (
                <>
                    {screen === 'setup' && <SetupScreen onStart={startQuiz} onStartSkyView={startSkyView} constellationData={constellationData} initialConfig={savedConfig} />}
                    {screen === 'quiz' && (
                        <QuizScreen
                            config={config}
                            quizState={quizState}
                            onAnswer={handleAnswer}
                            onNext={nextQuestion}
                            onBack={backToSetup}
                        />
                    )}
                    {screen === 'results' && (
                        <ResultsScreen
                            quizState={quizState}
                            onRestart={restartQuiz}
                            onNewQuiz={newQuiz}
                        />
                    )}
                    {screen === 'skyview' && (
                        <SkyViewScreen
                            constellationData={constellationData}
                            onBack={backToSetup}
                        />
                    )}
                </>
            );
        }

        // Generate quiz questions based on config
        function generateQuestions(config, constellationData, starCatalogData) {
            const { hemisphere, difficulty, season, numQuestions, inputMode, renderMode, showLines, randomRotation, maxMagnitude, showBackgroundStars, backgroundStarOpacity } = config;

            // Filter constellations
            let pool = Object.entries(constellationData).filter(([abbrev, data]) => {
                const matchesHemisphere = hemisphere === 'both' || data.hemisphere === hemisphere;
                const matchesDifficulty = difficulty === 'all' || data.difficulty === difficulty;
                const matchesSeason = season === 'all' || data.seasons.includes(season);
                return matchesHemisphere && matchesDifficulty && matchesSeason;
            });

            // Shuffle and limit
            pool = shuffleArray(pool);
            const count = numQuestions === 'endless' ? pool.length : Math.min(numQuestions, pool.length);
            pool = pool.slice(0, count);

            // Generate questions with multiple choice options
            return pool.map(([abbrev, data]) => {
                const wrongAnswers = generateWrongAnswers(abbrev, data, pool, 3);
                const allChoices = shuffleArray([
                    { abbrev, name: data.name, correct: true },
                    ...wrongAnswers.map(w => ({ abbrev: w[0], name: w[1].name, correct: false }))
                ]);

                // Generate random rotation angle (0-360 degrees) if rotation is enabled
                const rotationAngle = randomRotation ? Math.random() * 360 : 0;

                return {
                    constellation: { abbrev, ...data },
                    choices: allChoices,
                    showLines,
                    renderMode,
                    maxMagnitude,
                    rotationAngle,
                    backgroundStars: (starCatalogData && starCatalogData[abbrev]) || [],
                    backgroundStarOpacity
                };
            });
        }

        // Generate wrong answer choices from same hemisphere
        function generateWrongAnswers(correctAbbrev, correctData, pool, count) {
            const candidates = pool.filter(([abbrev, data]) =>
                abbrev !== correctAbbrev && data.hemisphere === correctData.hemisphere
            );

            // If not enough from same hemisphere, add from other hemispheres
            if (candidates.length < count) {
                const candidateAbbrevs = new Set(candidates.map(([abbrev]) => abbrev));
                const others = pool.filter(([abbrev]) =>
                    abbrev !== correctAbbrev && !candidateAbbrevs.has(abbrev)
                );

                // Combine and ensure uniqueness
                const combined = [...candidates, ...others];
                return shuffleArray(combined).slice(0, count);
            }

            return shuffleArray(candidates).slice(0, count);
        }

        // Shuffle array utility
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        // Setup Screen Component
        function SetupScreen({ onStart, onStartSkyView, initialConfig }) {
            const [hemisphere, setHemisphere] = useState(initialConfig?.hemisphere || 'both');
            const [difficulty, setDifficulty] = useState(initialConfig?.difficulty || 'all');
            const [season, setSeason] = useState(initialConfig?.season || 'all');
            const [numQuestions, setNumQuestions] = useState(initialConfig?.numQuestions || 10);
            const [inputMode, setInputMode] = useState(initialConfig?.inputMode || 'multiple-choice');
            const [renderMode, setRenderMode] = useState(initialConfig?.renderMode || 'canvas');
            const [showLines, setShowLines] = useState(initialConfig?.showLines ?? true);
            const [randomRotation, setRandomRotation] = useState(initialConfig?.randomRotation || false);
            const [maxMagnitude, setMaxMagnitude] = useState(initialConfig?.maxMagnitude || 6);
            const [showBackgroundStars, setShowBackgroundStars] = useState(initialConfig?.showBackgroundStars ?? true);
            const [backgroundStarOpacity, setBackgroundStarOpacity] = useState(initialConfig?.backgroundStarOpacity || 50);

            const handleStart = () => {
                onStart({
                    hemisphere,
                    difficulty,
                    season,
                    numQuestions,
                    inputMode,
                    renderMode,
                    showLines,
                    randomRotation,
                    maxMagnitude,
                    showBackgroundStars,
                    backgroundStarOpacity
                });
            };

            return (
                <div>
                    <h1>üåü Constellation Quiz</h1>
                    <p className="subtitle">Learn to identify all 88 constellations by their star patterns</p>

                    <div className="card">
                        <div className="setup-grid">
                            <div className="form-group">
                                <label htmlFor="hemisphere">Hemisphere</label>
                                <select
                                    id="hemisphere"
                                    value={hemisphere}
                                    onChange={(e) => setHemisphere(e.target.value)}
                                >
                                    <option value="both">Both Hemispheres</option>
                                    <option value="north">Northern Only</option>
                                    <option value="south">Southern Only</option>
                                </select>
                            </div>

                            <div className="form-group">
                                <label htmlFor="difficulty">Difficulty</label>
                                <select
                                    id="difficulty"
                                    value={difficulty}
                                    onChange={(e) => setDifficulty(e.target.value)}
                                >
                                    <option value="all">All Difficulties</option>
                                    <option value="easy">Easy (20 constellations)</option>
                                    <option value="medium">Medium (36 constellations)</option>
                                    <option value="hard">Hard (32 constellations)</option>
                                </select>
                            </div>

                            <div className="form-group">
                                <label htmlFor="season">Season Visibility</label>
                                <select
                                    id="season"
                                    value={season}
                                    onChange={(e) => setSeason(e.target.value)}
                                >
                                    <option value="all">All Seasons</option>
                                    <option value="winter">Winter</option>
                                    <option value="spring">Spring</option>
                                    <option value="summer">Summer</option>
                                    <option value="autumn">Autumn</option>
                                </select>
                            </div>

                            <div className="form-group">
                                <label htmlFor="numQuestions">Number of Questions</label>
                                <select
                                    id="numQuestions"
                                    value={numQuestions}
                                    onChange={(e) => setNumQuestions(e.target.value === 'endless' ? 'endless' : parseInt(e.target.value))}
                                >
                                    <option value="10">10 Questions</option>
                                    <option value="20">20 Questions</option>
                                    <option value="50">50 Questions</option>
                                    <option value="endless">All Available</option>
                                </select>
                            </div>

                            <div className="form-group">
                                <label htmlFor="inputMode">Input Mode</label>
                                <select
                                    id="inputMode"
                                    value={inputMode}
                                    onChange={(e) => setInputMode(e.target.value)}
                                >
                                    <option value="multiple-choice">Multiple Choice (4 options)</option>
                                    <option value="text">Text Input</option>
                                </select>
                            </div>

                            <div className="form-group">
                                <label htmlFor="renderMode">Rendering Mode</label>
                                <select
                                    id="renderMode"
                                    value={renderMode}
                                    onChange={(e) => setRenderMode(e.target.value)}
                                >
                                    <option value="canvas">Canvas (Graphical)</option>
                                    <option value="ascii">ASCII Art</option>
                                </select>
                            </div>

                            <div className="checkbox-group">
                                <input
                                    type="checkbox"
                                    id="showLines"
                                    checked={showLines}
                                    onChange={(e) => setShowLines(e.target.checked)}
                                />
                                <label htmlFor="showLines">Show constellation lines</label>
                            </div>

                            <div className="checkbox-group">
                                <input
                                    type="checkbox"
                                    id="randomRotation"
                                    checked={randomRotation}
                                    onChange={(e) => setRandomRotation(e.target.checked)}
                                />
                                <label htmlFor="randomRotation">Random rotation (harder!)</label>
                            </div>

                            <div className="form-group">
                                <label htmlFor="maxMagnitude">
                                    Star Brightness Filter (Mag ‚â§ {maxMagnitude.toFixed(1)})
                                </label>
                                <input
                                    type="range"
                                    id="maxMagnitude"
                                    list="magnitude-presets"
                                    min="0"
                                    max="14"
                                    step="0.5"
                                    value={maxMagnitude}
                                    onChange={(e) => setMaxMagnitude(parseFloat(e.target.value))}
                                    style={{width: '100%'}}
                                />
                                <datalist id="magnitude-presets">
                                    <option value="2.5" label="City"></option>
                                    <option value="4.0" label="Suburban"></option>
                                    <option value="5.0" label="Rural"></option>
                                    <option value="6.0" label="Dark Sky"></option>
                                    <option value="10.0" label="Binoculars"></option>
                                    <option value="14.0" label="Telescope"></option>
                                </datalist>
                                <div style={{display: 'grid', gridTemplateColumns: 'repeat(6, 1fr)', fontSize: '0.7rem', color: '#94a3b8', marginTop: '0.25rem', textAlign: 'center'}}>
                                    <span>Bright City<br/>(2.5)</span>
                                    <span>Suburban<br/>(4.0)</span>
                                    <span>Rural<br/>(5.0)</span>
                                    <span>Dark Sky<br/>(6.0)</span>
                                    <span>Binoculars<br/>(10.0)</span>
                                    <span>Telescope<br/>(14.0)</span>
                                </div>
                            </div>

                            <div className="form-group">
                                <label>
                                    <input
                                        type="checkbox"
                                        id="showBackgroundStars"
                                        checked={showBackgroundStars}
                                        onChange={(e) => setShowBackgroundStars(e.target.checked)}
                                    />
                                    {' '}Show Background Stars
                                </label>
                            </div>

                            {showBackgroundStars && renderMode === 'canvas' && (
                                <div className="form-group">
                                    <label htmlFor="backgroundStarOpacity">
                                        Background Star Opacity: {backgroundStarOpacity}%
                                    </label>
                                    <input
                                        type="range"
                                        id="backgroundStarOpacity"
                                        min="0"
                                        max="100"
                                        step="5"
                                        value={backgroundStarOpacity}
                                        onChange={(e) => setBackgroundStarOpacity(Number(e.target.value))}
                                    />
                                </div>
                            )}
                        </div>

                        <button className="button-primary" onClick={handleStart}>
                            Start Quiz
                        </button>

                        <button className="button-secondary" onClick={onStartSkyView} style={{marginTop: '0.5rem', width: '100%'}}>
                            Sky View Mode (Beta)
                        </button>
                    </div>
                </div>
            );
        }

        // Constellation Canvas Component
        function ConstellationCanvas({ constellation, showLines, maxMagnitude = 6, rotationAngle = 0, backgroundStars = [], backgroundStarOpacity = 100 }) {
            const canvasRef = useRef(null);

            useEffect(() => {
                if (!canvasRef.current) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const width = canvas.width = 500;
                const height = canvas.height = 500;

                // Clear canvas
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, width, height);

                const { stars, lines } = constellation;

                // Process coordinates with rotation and bounds fitting (ALWAYS for consistent scaling)
                let processedStars = stars.map(s => ({ ...s }));
                let processedBackgroundStars = backgroundStars ? backgroundStars.map(s => ({ ...s })) : [];

                // Calculate constellation center
                const centerX = stars.reduce((sum, s) => sum + s.x, 0) / stars.length;
                const centerY = stars.reduce((sum, s) => sum + s.y, 0) / stars.length;
                const angleRad = rotationAngle * Math.PI / 180;

                // Rotate all coordinates (constellation stars)
                processedStars = stars.map(star => {
                    const dx = star.x - centerX;
                    const dy = star.y - centerY;
                    const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                    const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                    return {
                        ...star,
                        x: rotatedX + centerX,
                        y: rotatedY + centerY
                    };
                });

                // Rotate background stars around same center
                if (backgroundStars && backgroundStars.length > 0) {
                    processedBackgroundStars = backgroundStars.map(star => {
                        const dx = star.x - centerX;
                        const dy = star.y - centerY;
                        const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                        const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                        return {
                            ...star,
                            x: rotatedX + centerX,
                            y: rotatedY + centerY
                        };
                    });
                }

                // Find bounding box of rotated constellation
                const minX = Math.min(...processedStars.map(s => s.x));
                const maxX = Math.max(...processedStars.map(s => s.x));
                const minY = Math.min(...processedStars.map(s => s.y));
                const maxY = Math.max(...processedStars.map(s => s.y));

                // Calculate scale to fit within 0-1 range with 10% padding
                const spanX = maxX - minX;
                const spanY = maxY - minY;
                const scale = Math.min(0.9 / spanX, 0.9 / spanY);

                // Normalize and center constellation stars
                processedStars = processedStars.map(star => {
                    const scaledX = (star.x - minX) * scale;
                    const scaledY = (star.y - minY) * scale;
                    const offsetX = (1 - spanX * scale) / 2;
                    const offsetY = (1 - spanY * scale) / 2;
                    return {
                        ...star,
                        x: scaledX + offsetX,
                        y: scaledY + offsetY
                    };
                });

                // Apply same normalization to background stars
                if (backgroundStars && backgroundStars.length > 0) {
                    processedBackgroundStars = processedBackgroundStars.map(star => {
                        const scaledX = (star.x - minX) * scale;
                        const scaledY = (star.y - minY) * scale;
                        const offsetX = (1 - spanX * scale) / 2;
                        const offsetY = (1 - spanY * scale) / 2;
                        return {
                            ...star,
                            x: scaledX + offsetX,
                            y: scaledY + offsetY
                        };
                    });
                }

                // Draw background stars first (behind constellation)
                if (processedBackgroundStars.length > 0) {
                    ctx.globalAlpha = backgroundStarOpacity / 100;

                    processedBackgroundStars.forEach(star => {
                        const mag = star.mag || 5;
                        if (mag > maxMagnitude) return;

                        const x = star.x * width;
                        const y = (1 - star.y) * height;

                        // Skip stars outside visible canvas area
                        if (x < -10 || x > width + 10 || y < -10 || y > height + 10) return;

                        const radius = Math.max(0.5, 6 * Math.pow(10, -(mag + 1.5) / 6.5));

                        // Glow effect for bright stars
                        if (mag < 2.5) {
                            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
                            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
                            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Draw star
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    ctx.globalAlpha = 1.0;
                }

                // Draw lines first (if enabled)
                if (showLines && lines) {
                    ctx.strokeStyle = '#475569';
                    ctx.lineWidth = 1.5;

                    lines.forEach(([idx1, idx2]) => {
                        if (idx1 < processedStars.length && idx2 < processedStars.length) {
                            const star1 = processedStars[idx1];
                            const star2 = processedStars[idx2];
                            const x1 = star1.x * width;
                            const y1 = (1 - star1.y) * height;
                            const x2 = star2.x * width;
                            const y2 = (1 - star2.y) * height;

                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        }
                    });
                }

                // Draw stars (filtered by magnitude)
                processedStars.forEach(star => {
                    const mag = star.magnitude || 5;

                    // Skip stars dimmer than the filter threshold
                    if (mag > maxMagnitude) return;

                    const x = star.x * width;
                    const y = (1 - star.y) * height;

                    // Logarithmic size based on magnitude (more astronomically accurate)
                    const radius = Math.max(0.5, 6 * Math.pow(10, -(mag + 1.5) / 6.5));

                    // Glow effect for bright stars
                    if (mag < 2.5) {
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(147, 197, 253, 0.3)');
                        gradient.addColorStop(1, 'rgba(147, 197, 253, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Star itself
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                });

            }, [constellation, showLines, maxMagnitude, rotationAngle, backgroundStars, backgroundStarOpacity]);

            return <canvas ref={canvasRef} width="500" height="500" />;
        }

        // Sky View Canvas - Multiple constellations in correct positions
        function SkyViewCanvas({
            constellations,           // All constellation data
            highlightedAbbrev,        // Which constellation to highlight
            showBoundaries,           // Show boundary polygons
            showLabels,               // Show constellation names
            showLines,                // Show constellation lines
            maxMagnitude,             // Star brightness filter
            onClick                   // Click handler: (abbrev, x, y) => void
        }) {
            const canvasRef = useRef(null);
            const hemisphereSize = 700;  // Each hemisphere circle size
            const canvasWidth = hemisphereSize * 2 + 40;  // Two hemispheres + gap
            const canvasHeight = hemisphereSize + 60;  // Plus labels

            // Convert RA hours to radians
            const raToRad = (raHours) => raHours * 15 * Math.PI / 180;
            const decToRad = (decDeg) => decDeg * Math.PI / 180;

            // Stereographic projection for a specific hemisphere
            // hemisphere: 'north' (Dec +90 center) or 'south' (Dec -90 center)
            const projectToHemisphere = (ra, dec, hemisphere) => {
                const centerDec = hemisphere === 'north' ? 90 : -90;
                const centerDecRad = decToRad(centerDec);
                const raRad = raToRad(ra);
                const decRad = decToRad(dec);

                // Compute angular distance from pole
                const cosDist = Math.sin(centerDecRad) * Math.sin(decRad) +
                               Math.cos(centerDecRad) * Math.cos(decRad);  // cos(dRA) = 1 at poles
                const angularDist = Math.acos(Math.max(-1, Math.min(1, cosDist)));

                // For polar projection, position angle is just RA
                // North: RA increases clockwise when looking down from north
                // South: RA increases counter-clockwise when looking up from south
                const posAngle = hemisphere === 'north' ? -raRad : raRad;

                // Stereographic projection: 90¬∞ from center maps to edge
                const viewRadiusRad = 90 * Math.PI / 180;
                const r = 2.0 * Math.tan(angularDist / 2);
                const edgeR = 2.0 * Math.tan(viewRadiusRad / 2);
                const scale = (hemisphereSize / 2) / edgeR;

                const projX = r * Math.sin(posAngle) * scale;
                const projY = r * Math.cos(posAngle) * scale;

                // Calculate canvas position based on hemisphere
                const centerX = hemisphere === 'north' ? hemisphereSize / 2 + 10 : hemisphereSize * 1.5 + 30;
                const centerY = hemisphereSize / 2 + 40;

                return {
                    x: centerX + projX,
                    y: centerY - projY,
                    angularDist: angularDist * 180 / Math.PI,
                    visible: angularDist * 180 / Math.PI <= 90
                };
            };

            // Check which hemisphere a constellation belongs to (by center dec)
            const getHemisphere = (dec) => dec >= 0 ? 'north' : 'south';

            // Store boundary paths for hit testing (keyed by "abbrev-hemisphere")
            const boundaryPathsRef = useRef(new Map());

            // Handle canvas click using Canvas API isPointInPath
            const handleClick = (e) => {
                if (!onClick) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const rect = canvas.getBoundingClientRect();

                // Get click position and scale to internal canvas coordinates
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;

                // Check each constellation's boundary path
                for (const [key, path] of boundaryPathsRef.current.entries()) {
                    if (ctx.isPointInPath(path, x, y)) {
                        const abbrev = key.split('-')[0];
                        onClick(abbrev, x, y);
                        return;
                    }
                }

                // No constellation found
                onClick(null, x, y);
            };

            useEffect(() => {
                if (!canvasRef.current || !constellations) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                // Clear entire canvas
                ctx.fillStyle = '#0f172a';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                // Draw hemisphere labels
                ctx.fillStyle = '#94a3b8';
                ctx.font = '14px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Northern Hemisphere', hemisphereSize / 2 + 10, 25);
                ctx.fillText('Southern Hemisphere', hemisphereSize * 1.5 + 30, 25);

                // Clear stored paths and rebuild
                boundaryPathsRef.current.clear();

                const allConstellations = Object.entries(constellations);

                // Draw each hemisphere
                for (const hemisphere of ['north', 'south']) {
                    const centerX = hemisphere === 'north' ? hemisphereSize / 2 + 10 : hemisphereSize * 1.5 + 30;
                    const centerY = hemisphereSize / 2 + 40;

                    // Apply circular clipping for this hemisphere
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, hemisphereSize / 2, 0, Math.PI * 2);
                    ctx.clip();

                    // Fill with background
                    ctx.fillStyle = '#0f172a';
                    ctx.fillRect(centerX - hemisphereSize / 2, centerY - hemisphereSize / 2, hemisphereSize, hemisphereSize);

                    // Build Path2D for constellations in this hemisphere
                    for (const [abbrev, data] of allConstellations) {
                        if (!data.boundary || data.boundary.length < 3) continue;

                        // Check if any boundary point is visible in this hemisphere
                        const anyVisible = data.boundary.some(([ra, dec]) => {
                            const pt = projectToHemisphere(ra, dec, hemisphere);
                            return pt.visible;
                        });
                        if (!anyVisible) continue;

                        // Create Path2D for this constellation in this hemisphere
                        const path = new Path2D();
                        const first = projectToHemisphere(data.boundary[0][0], data.boundary[0][1], hemisphere);
                        path.moveTo(first.x, first.y);

                        for (let i = 1; i < data.boundary.length; i++) {
                            const pt = projectToHemisphere(data.boundary[i][0], data.boundary[i][1], hemisphere);
                            path.lineTo(pt.x, pt.y);
                        }
                        path.closePath();

                        // Store for hit testing
                        boundaryPathsRef.current.set(`${abbrev}-${hemisphere}`, path);

                        // Draw the path (only if showBoundaries)
                        if (showBoundaries) {
                            const isHighlighted = abbrev === highlightedAbbrev;
                            if (isHighlighted) {
                                ctx.fillStyle = 'rgba(59, 130, 246, 0.15)';
                                ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
                                ctx.lineWidth = 2;
                                ctx.fill(path);
                            } else {
                                ctx.strokeStyle = 'rgba(71, 85, 105, 0.3)';
                                ctx.lineWidth = 1;
                            }
                            ctx.stroke(path);
                        }
                    }

                    // Draw constellation lines
                    if (showLines) {
                        for (const [abbrev, data] of allConstellations) {
                            const isHighlighted = abbrev === highlightedAbbrev;
                            ctx.strokeStyle = isHighlighted ? '#60a5fa' : '#475569';
                            ctx.lineWidth = isHighlighted ? 2 : 1;

                            const stars = data.stars;

                            for (const [idx1, idx2] of data.lines) {
                                if (idx1 < stars.length && idx2 < stars.length) {
                                    const star1 = stars[idx1];
                                    const star2 = stars[idx2];

                                    const p1 = projectToHemisphere(star1.ra, star1.dec, hemisphere);
                                    const p2 = projectToHemisphere(star2.ra, star2.dec, hemisphere);

                                    // Draw if at least one point is visible (clipping handles the rest)
                                    if (p1.visible || p2.visible) {
                                        ctx.beginPath();
                                        ctx.moveTo(p1.x, p1.y);
                                        ctx.lineTo(p2.x, p2.y);
                                        ctx.stroke();
                                    }
                                }
                            }
                        }
                    }

                    // Draw stars
                    for (const [abbrev, data] of allConstellations) {
                        const isHighlighted = abbrev === highlightedAbbrev;

                        for (const star of data.stars) {
                            const mag = star.magnitude || 5;
                            if (mag > maxMagnitude) continue;

                            const pt = projectToHemisphere(star.ra, star.dec, hemisphere);
                            if (!pt.visible) continue;

                            const { x, y } = pt;
                            const radius = Math.max(0.5, 3.5 * Math.pow(10, -(mag + 1.5) / 6.5));

                            // Glow for bright stars
                            if (mag < 2.5) {
                                const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
                                gradient.addColorStop(0, isHighlighted ? 'rgba(96, 165, 250, 0.8)' : 'rgba(255, 255, 255, 0.8)');
                                gradient.addColorStop(0.5, isHighlighted ? 'rgba(96, 165, 250, 0.3)' : 'rgba(255, 255, 255, 0.3)');
                                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                                ctx.fillStyle = gradient;
                                ctx.beginPath();
                                ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
                                ctx.fill();
                            }

                            ctx.fillStyle = isHighlighted ? '#60a5fa' : '#ffffff';
                            ctx.beginPath();
                            ctx.arc(x, y, radius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Draw labels
                    if (showLabels) {
                        ctx.font = '10px -apple-system, sans-serif';
                        ctx.textAlign = 'center';

                        for (const [abbrev, data] of allConstellations) {
                            const isHighlighted = abbrev === highlightedAbbrev;
                            const pt = projectToHemisphere(data.ra_center, data.dec_center, hemisphere);

                            if (pt.visible && pt.angularDist < 85) {
                                ctx.fillStyle = isHighlighted ? '#60a5fa' : 'rgba(148, 163, 184, 0.7)';
                                ctx.fillText(data.name, pt.x, pt.y);
                            }
                        }
                    }

                    // Restore context (removes clipping)
                    ctx.restore();

                    // Draw circular border
                    ctx.strokeStyle = '#334155';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, hemisphereSize / 2 - 1, 0, Math.PI * 2);
                    ctx.stroke();
                }

            }, [constellations, highlightedAbbrev, showBoundaries, showLabels, showLines, maxMagnitude]);

            return (
                <canvas
                    ref={canvasRef}
                    width={canvasWidth}
                    height={canvasHeight}
                    onClick={handleClick}
                    style={{
                        cursor: onClick ? 'crosshair' : 'default',
                        width: '100%',
                        maxWidth: `${canvasWidth}px`,
                        height: 'auto',
                        border: 'none'
                    }}
                />
            );
        }

        // Sky View Quiz Screen
        function SkyViewScreen({ constellationData, onBack }) {
            const [targetAbbrev, setTargetAbbrev] = useState(null);
            const [score, setScore] = useState({ correct: 0, total: 0 });
            const [feedback, setFeedback] = useState(null);
            const [showLabels, setShowLabels] = useState(false);

            // Pick a random constellation
            const pickNewTarget = () => {
                if (!constellationData) return;

                const allAbbrevs = Object.keys(constellationData);
                // Pick random one, different from current if possible
                let candidates = allAbbrevs.filter(a => a !== targetAbbrev);
                if (candidates.length === 0) candidates = allAbbrevs;

                const newTarget = candidates[Math.floor(Math.random() * candidates.length)];
                setTargetAbbrev(newTarget);
                setFeedback(null);
            };

            // Initialize on first load
            useEffect(() => {
                pickNewTarget();
            }, [constellationData]);

            // Get total constellation count (all are visible in dual-hemisphere view)
            const getTotalConstellations = () => {
                if (!constellationData) return 0;
                return Object.keys(constellationData).length;
            };

            // Handle tap on constellation
            const handleTap = (tappedAbbrev, x, y) => {
                if (feedback) return; // Already answered

                const isCorrect = tappedAbbrev === targetAbbrev;
                const tappedName = tappedAbbrev ? constellationData[tappedAbbrev]?.name : 'empty space';
                const targetName = constellationData[targetAbbrev]?.name;

                setScore(prev => ({
                    correct: prev.correct + (isCorrect ? 1 : 0),
                    total: prev.total + 1
                }));

                setFeedback({
                    correct: isCorrect,
                    message: isCorrect
                        ? `Correct! That's ${targetName}`
                        : `Incorrect. You tapped ${tappedName}. ${targetName} is highlighted.`
                });
            };

            const handleNext = () => {
                pickNewTarget();
            };

            if (!constellationData) {
                return <div className="loading">Loading constellation data...</div>;
            }

            const targetData = targetAbbrev ? constellationData[targetAbbrev] : null;
            const targetName = targetData?.name || '...';
            const targetHemisphere = targetData?.dec_center >= 0 ? 'Northern' : 'Southern';
            const percentage = score.total > 0 ? Math.round((score.correct / score.total) * 100) : 0;

            return (
                <div className="sky-view-screen">
                    <div className="quiz-header">
                        <button className="back-button" onClick={onBack}>
                            ‚Üê Back to Menu
                        </button>
                        <div className="score">
                            Score: {score.correct}/{score.total} ({percentage}%)
                        </div>
                    </div>

                    <div className="card">
                        <div style={{marginBottom: '1rem', textAlign: 'right'}}>
                            <label>
                                <input
                                    type="checkbox"
                                    checked={showLabels}
                                    onChange={(e) => setShowLabels(e.target.checked)}
                                />
                                {' '}Show labels
                            </label>
                        </div>

                        <h2 style={{textAlign: 'center', marginBottom: '0.5rem'}}>
                            Tap on: <span style={{color: '#60a5fa'}}>{targetName}</span>
                        </h2>
                        <div style={{textAlign: 'center', marginBottom: '1rem', fontSize: '0.85rem', color: '#64748b'}}>
                            ({targetHemisphere} Hemisphere)
                        </div>

                        <SkyViewCanvas
                            constellations={constellationData}
                            highlightedAbbrev={feedback ? targetAbbrev : null}
                            showBoundaries={true}
                            showLabels={showLabels}
                            showLines={true}
                            maxMagnitude={5}
                            onClick={handleTap}
                        />

                        {feedback && (
                            <div className={`feedback ${feedback.correct ? 'correct' : 'incorrect'}`}>
                                {feedback.message}
                            </div>
                        )}

                        {feedback && (
                            <button
                                className="button-primary"
                                onClick={handleNext}
                                style={{marginTop: '1rem'}}
                            >
                                Next Constellation ‚Üí
                            </button>
                        )}

                        <div style={{marginTop: '1rem', fontSize: '0.85rem', color: '#94a3b8', textAlign: 'center'}}>
                            Total constellations: {getTotalConstellations()}
                        </div>
                    </div>
                </div>
            );
        }

        // ASCII Constellation Component
        function ASCIIConstellation({ constellation, showLines, maxMagnitude = 6, rotationAngle = 0, backgroundStars = [] }) {
            const ascii = useMemo(() => {
                const { stars, lines } = constellation;
                const width = 70;
                const height = 45;

                // Create character grid
                const grid = Array(height).fill().map(() => Array(width).fill(' '));

                // Process coordinates with rotation and bounds fitting (ALWAYS for consistent scaling)
                let processedStars = stars.map(s => ({ ...s }));
                let processedBackgroundStars = backgroundStars ? backgroundStars.map(s => ({ ...s })) : [];

                // Calculate constellation center
                const centerX = stars.reduce((sum, s) => sum + s.x, 0) / stars.length;
                const centerY = stars.reduce((sum, s) => sum + s.y, 0) / stars.length;
                const angleRad = rotationAngle * Math.PI / 180;

                // Rotate all coordinates (constellation stars)
                processedStars = stars.map(star => {
                    const dx = star.x - centerX;
                    const dy = star.y - centerY;
                    const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                    const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                    return {
                        ...star,
                        x: rotatedX + centerX,
                        y: rotatedY + centerY
                    };
                });

                // Rotate background stars around same center
                if (backgroundStars && backgroundStars.length > 0) {
                    processedBackgroundStars = backgroundStars.map(star => {
                        const dx = star.x - centerX;
                        const dy = star.y - centerY;
                        const rotatedX = dx * Math.cos(angleRad) - dy * Math.sin(angleRad);
                        const rotatedY = dx * Math.sin(angleRad) + dy * Math.cos(angleRad);
                        return {
                            ...star,
                            x: rotatedX + centerX,
                            y: rotatedY + centerY
                        };
                    });
                }

                // Find bounding box of rotated constellation
                const minX = Math.min(...processedStars.map(s => s.x));
                const maxX = Math.max(...processedStars.map(s => s.x));
                const minY = Math.min(...processedStars.map(s => s.y));
                const maxY = Math.max(...processedStars.map(s => s.y));

                // Calculate scale to fit within 0-1 range with 10% padding
                const spanX = maxX - minX;
                const spanY = maxY - minY;
                const scale = Math.min(0.9 / spanX, 0.9 / spanY);

                // Normalize and center constellation stars
                processedStars = processedStars.map(star => {
                    const scaledX = (star.x - minX) * scale;
                    const scaledY = (star.y - minY) * scale;
                    const offsetX = (1 - spanX * scale) / 2;
                    const offsetY = (1 - spanY * scale) / 2;
                    return {
                        ...star,
                        x: scaledX + offsetX,
                        y: scaledY + offsetY
                    };
                });

                // Apply same normalization to background stars
                if (backgroundStars && backgroundStars.length > 0) {
                    processedBackgroundStars = processedBackgroundStars.map(star => {
                        const scaledX = (star.x - minX) * scale;
                        const scaledY = (star.y - minY) * scale;
                        const offsetX = (1 - spanX * scale) / 2;
                        const offsetY = (1 - spanY * scale) / 2;
                        return {
                            ...star,
                            x: scaledX + offsetX,
                            y: scaledY + offsetY
                        };
                    });
                }

                // Draw background stars first (behind constellation)
                if (processedBackgroundStars.length > 0) {
                    processedBackgroundStars.forEach(star => {
                        const mag = star.mag || 5;
                        if (mag > maxMagnitude) return;

                        const x = Math.round(star.x * (width - 1));
                        const y = Math.round((1 - star.y) * (height - 1));

                        let symbol;
                        if (mag < 1.0) symbol = '‚¨§';
                        else if (mag < 2.5) symbol = '‚óè';
                        else if (mag < 4.0) symbol = '‚óã';
                        else symbol = '‚àò';

                        if (x >= 0 && x < width && y >= 0 && y < height) {
                            grid[y][x] = symbol;
                        }
                    });
                }

                // Bresenham line drawing algorithm
                const drawLine = (x1, y1, x2, y2) => {
                    const dx = Math.abs(x2 - x1);
                    const dy = Math.abs(y2 - y1);
                    const sx = x1 < x2 ? 1 : -1;
                    const sy = y1 < y2 ? 1 : -1;
                    let err = dx - dy;

                    while (true) {
                        if (x1 >= 0 && x1 < width && y1 >= 0 && y1 < height) {
                            if (grid[y1][x1] === ' ') {
                                grid[y1][x1] = '¬∑';
                            }
                        }

                        if (x1 === x2 && y1 === y2) break;

                        const e2 = 2 * err;
                        if (e2 > -dy) {
                            err -= dy;
                            x1 += sx;
                        }
                        if (e2 < dx) {
                            err += dx;
                            y1 += sy;
                        }
                    }
                };

                // Draw lines first (if enabled)
                if (showLines && lines) {
                    lines.forEach(([idx1, idx2]) => {
                        if (idx1 < processedStars.length && idx2 < processedStars.length) {
                            const star1 = processedStars[idx1];
                            const star2 = processedStars[idx2];

                            const x1 = Math.round(star1.x * (width - 1));
                            const y1 = Math.round((1 - star1.y) * (height - 1));
                            const x2 = Math.round(star2.x * (width - 1));
                            const y2 = Math.round((1 - star2.y) * (height - 1));
                            drawLine(x1, y1, x2, y2);
                        }
                    });
                }

                // Draw stars on top (filtered by magnitude)
                processedStars.forEach(star => {
                    const mag = star.magnitude || 5;

                    // Skip stars dimmer than the filter threshold
                    if (mag > maxMagnitude) return;

                    const x = Math.round(star.x * (width - 1));
                    const y = Math.round((1 - star.y) * (height - 1));

                    // Symbol based on magnitude
                    let symbol;
                    if (mag < 1.0) symbol = '‚¨§';
                    else if (mag < 2.5) symbol = '‚óè';
                    else if (mag < 4.0) symbol = '‚óã';
                    else symbol = '‚àò';

                    if (x >= 0 && x < width && y >= 0 && y < height) {
                        grid[y][x] = symbol;
                    }
                });

                // Convert grid to string
                return grid.map(row => row.join('')).join('\n');
            }, [constellation, showLines, maxMagnitude, rotationAngle, backgroundStars]);

            return (
                <div className="ascii-container">
                    <div className="ascii-art">{ascii}</div>
                </div>
            );
        }

        // Quiz Screen Component
        function QuizScreen({ config, quizState, onAnswer, onNext, onBack }) {
            const [selectedAnswer, setSelectedAnswer] = useState(null);
            const [textInput, setTextInput] = useState('');
            const [feedback, setFeedback] = useState(null);
            const [showNextButton, setShowNextButton] = useState(false);
            const [currentShowLines, setCurrentShowLines] = useState(false);

            const currentQuestion = quizState.questions[quizState.currentIndex];
            const isTextMode = config.inputMode === 'text';

            // Reset state when question changes
            useEffect(() => {
                setSelectedAnswer(null);
                setTextInput('');
                setFeedback(null);
                setShowNextButton(false);
                setCurrentShowLines(currentQuestion.showLines);
            }, [quizState.currentIndex, currentQuestion.showLines]);

            const handleMultipleChoiceAnswer = (choice) => {
                if (feedback) return; // Already answered

                setSelectedAnswer(choice);
                const isCorrect = choice.correct;

                // Reveal lines after guessing (if lines were originally off)
                if (!currentQuestion.showLines) {
                    setCurrentShowLines(true);
                }

                onAnswer(isCorrect, choice.name, currentQuestion.constellation.name);
                setFeedback({
                    correct: isCorrect,
                    message: isCorrect
                        ? '‚úì Correct!'
                        : `‚úó Incorrect. The correct answer is ${currentQuestion.constellation.name}`
                });
                setShowNextButton(true);
            };

            const handleTextInputSubmit = (e) => {
                e.preventDefault();
                if (feedback || !textInput.trim()) return;

                const userAnswer = textInput.trim().toLowerCase();
                const correctAnswer = currentQuestion.constellation.name.toLowerCase();
                const correctAbbrev = currentQuestion.constellation.abbrev.toLowerCase();

                // Check if answer matches name or abbreviation
                const isCorrect = userAnswer === correctAnswer || userAnswer === correctAbbrev;

                // Reveal lines after guessing (if lines were originally off)
                if (!currentQuestion.showLines) {
                    setCurrentShowLines(true);
                }

                onAnswer(isCorrect, textInput, currentQuestion.constellation.name);
                setFeedback({
                    correct: isCorrect,
                    message: isCorrect
                        ? '‚úì Correct!'
                        : `‚úó Incorrect. The correct answer is ${currentQuestion.constellation.name}`
                });
                setShowNextButton(true);
            };

            const handleNext = () => {
                // Reset currentShowLines to match the NEXT question's setting before advancing
                // This prevents flickering where lines briefly appear before being hidden
                const nextIndex = quizState.currentIndex + 1;
                if (nextIndex < quizState.questions.length) {
                    const nextQuestion = quizState.questions[nextIndex];
                    setCurrentShowLines(nextQuestion.showLines);
                }
                onNext();
            };

            const progress = quizState.currentIndex + 1;
            const total = quizState.questions.length;
            const percentage = Math.round((quizState.score / progress) * 100);

            return (
                <div>
                    <div className="quiz-header">
                        <button className="back-button" onClick={onBack}>
                            ‚Üê Back to Menu
                        </button>
                        <div className="question-number">
                            Question {progress} of {total}
                        </div>
                        <div className="score">
                            Score: {quizState.score}/{progress} ({percentage}%)
                        </div>
                    </div>

                    <div className="card">
                        <div className="quiz-desktop-grid">
                            <div className="quiz-constellation-col">
                                {currentQuestion.renderMode === 'ascii' ? (
                                    <ASCIIConstellation
                                        constellation={currentQuestion.constellation}
                                        showLines={currentShowLines}
                                        maxMagnitude={currentQuestion.maxMagnitude}
                                        rotationAngle={currentQuestion.rotationAngle}
                                        backgroundStars={currentQuestion.backgroundStars}
                                    />
                                ) : (
                                    <ConstellationCanvas
                                        constellation={currentQuestion.constellation}
                                        showLines={currentShowLines}
                                        maxMagnitude={currentQuestion.maxMagnitude}
                                        rotationAngle={currentQuestion.rotationAngle}
                                        backgroundStars={currentQuestion.backgroundStars}
                                        backgroundStarOpacity={currentQuestion.backgroundStarOpacity}
                                    />
                                )}
                            </div>

                            <div className="quiz-interaction-col">
                                <h2 style={{textAlign: 'center', marginBottom: '1.5rem'}}>
                                    What constellation is this?
                                </h2>

                                {isTextMode ? (
                                    <div className="text-input-container">
                                        <form onSubmit={handleTextInputSubmit}>
                                            <input
                                                type="text"
                                                value={textInput}
                                                onChange={(e) => setTextInput(e.target.value)}
                                                placeholder="Enter constellation name..."
                                                disabled={feedback !== null}
                                                autoFocus
                                            />
                                            {!showNextButton && (
                                                <button type="submit" className="button-primary">
                                                    Submit Answer
                                                </button>
                                            )}
                                        </form>
                                    </div>
                                ) : (
                                    <div className="answer-grid">
                                        {currentQuestion.choices.map((choice, idx) => (
                                            <button
                                                key={idx}
                                                className={`answer-button ${
                                                    feedback && choice.correct ? 'correct' : ''
                                                } ${
                                                    feedback && selectedAnswer === choice && !choice.correct ? 'incorrect' : ''
                                                }`}
                                                onClick={() => handleMultipleChoiceAnswer(choice)}
                                                disabled={feedback !== null}
                                            >
                                                {choice.name}
                                            </button>
                                        ))}
                                    </div>
                                )}

                                {feedback && (
                                    <div className={`feedback ${feedback.correct ? 'correct' : 'incorrect'}`}>
                                        {feedback.message}
                                    </div>
                                )}

                                {showNextButton && (
                                    <button
                                        className="button-primary"
                                        onClick={handleNext}
                                        style={{marginTop: '1rem'}}
                                    >
                                        {progress < total ? 'Next Question ‚Üí' : 'See Results'}
                                    </button>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Results Screen Component
        function ResultsScreen({ quizState, onRestart, onNewQuiz }) {
            const total = quizState.questions.length;
            const score = quizState.score;
            const percentage = Math.round((score / total) * 100);
            const missed = quizState.answers.filter(a => !a.correct);

            let performanceMessage = '';
            if (percentage === 100) performanceMessage = 'Perfect Score! üéâ';
            else if (percentage >= 90) performanceMessage = 'Excellent! üåü';
            else if (percentage >= 75) performanceMessage = 'Great Job! ‚≠ê';
            else if (percentage >= 60) performanceMessage = 'Good Effort! üëç';
            else performanceMessage = 'Keep Practicing! üìö';

            return (
                <div>
                    <h1>Quiz Complete!</h1>

                    <div className="card">
                        <div className="results-summary">
                            <div className="score-big">{score}/{total}</div>
                            <div className="percentage">{percentage}% Correct</div>
                            <p style={{marginTop: '1rem', fontSize: '1.25rem'}}>{performanceMessage}</p>
                        </div>

                        {missed.length > 0 && (
                            <div style={{marginTop: '2rem'}}>
                                <h2>Missed Constellations ({missed.length})</h2>
                                <ul className="missed-list">
                                    {missed.map((answer, idx) => (
                                        <li key={idx}>
                                            <strong>{answer.constellation}</strong>
                                            {answer.userAnswer && ` ‚Äî You answered: ${answer.userAnswer}`}
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        )}

                        <div className="button-group">
                            <button className="button-primary" onClick={onRestart}>
                                Try Again (Same Settings)
                            </button>
                            <button className="button-secondary" onClick={onNewQuiz}>
                                New Quiz (Different Settings)
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // Render app
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
